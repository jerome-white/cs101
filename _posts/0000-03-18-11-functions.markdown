---
layout: post
title: "Lab 11: More functions"
categories: lab
date: 0000-03-18
---

## Main Event


### <a name="machine"></a>1. Number machines
Write the following functions:

* **Multiplier** Given a list, returns a new list with each element of
  the original list duplicated:
  
  ```
  >>> multiplier([1, 2, 3])
  [1, 1, 2, 2, 3, 3]
  ```

* **Consumer** Given a list, returns a new list with the first
  instance of the largest element removed:
  
  ```
  >>> consumer([1, 2, 5, 5, 3])
  [1, 2, 5, 3]
  ```
  
* **Blender** Given a list, returns a list with a single item: the sum
  of all numbers:
  
  ```
  >>> blender([1, 2, 3])
  [6]
  ```

Given a particular input, use these functions produce the following
output:

1. `[1, 2, 3, 4, 5, 6]` &rarr; `[50]`
2. `[2, 4, 5]` &rarr; `[121]`
3. `[1, 1, 1, 1, 5]` &rarr; `[26]`

Note that for all functions, the return values and the parameters are
of the same type. Thus, these tasks can be accomplished by "chaining"
the functions; for example,

```
>>> blender(consumer(multiplier([1, 2, 3])))
>>> [9]
```

For longer chains of function applications, this may create difficult
code to read; in these cases creating intermediate variables is a
better approach. Also, if you can identify places to use loops, you
are encouraged to do so.

If you are stuck, a good strategy is to first map the individual
functions to mathematical concepts. Next, understand what each
produces given the original list. Finally, with this knowledge, work
backwards from the expected output to come up with the sequence of
function calls to get the job done. If you are keen, try to come with
solutions that use fewer function calls than your neighbor.


### <a name="rps"></a>2. Rock-paper-scissors
To most, rock-paper-scissors is child's play. However, it's [very
real](https://nyti.ms/2ze7420). Today we will teach Python to play
and, for those who are diligent, answer once and for all how the game
should be played.

1. Write a function that takes two hands---rock, paper, or
   scissors---and returns an integer signifying whether hand 1 is
   "better-than" hand 2.

   A *hand* is an abstract concept---it is up to you to decide which
   data-type to use to represent it (hint: there's no wrong
   answer). The function declaration, and what it returns, should
   obey:

   ![](http://mathurl.com/y9dqjd7o.png)

   Here, greater-than implies that one hand is better-than the other.
  
2. Write another function that allows for interactive play. The
   function should take a single argument *rounds* denoting the number
   of games to be played.

   ```python
   def play(rounds)
   ```

   For each game, Player 1's decision about whether to use rock,
   paper, or scissors should come from user input. Player 2's decision
   should be randomly generated. Once the specified number of games
   have been completed, the function should return a list of three
   elements, where index

   * zero is the number of games that were a tie,
   * one is the number of games won by Player 1, and
   * two is the number of games won by Player 2.
  
3. In the global scope, interpret the return value and print a message
   about the result of the game.


## Additional Practice


### <a name="rps-additional"></a>1. Rock-paper-scissors: tournament
#### Players

Update `play` to take two "players," along with the number of rounds

```python
  def play(p1, p2, rounds)
```

One way to represent players are via "function pointers." In Python,
functions are
[first-class](https://en.wikipedia.org/wiki/First-class_function)
citizens, meaning they can be passed as arguments to other functions,
returned as the values from other functions, and assigned to
variables. For example:

```
>>> def f(g):
...     g('Hello')
... 
>>> h = f
>>> h(print)
Hello
```

Thus, if you create two functions---one that requests user input, and
another than chooses a random hand---you can effectively recreate the
game-play from the previous exercise:

```python
play(interactive, random_selection, 7)
```

where `interactive` and `random_selection` are functions that ask for
input, and return a random hand, respectively (the choice of seven for
the number of rounds was
[arbitrary](https://en.wikipedia.org/wiki/Playoff_format#Best-of-seven_playoff)).

#### Strategy

Write several functions that represent various playing
styles. Remember, a "player" just a function that returns some value
that corresponds to the data-type you've selected as hand.

Different playing styles might include

* Always playing a particular hand.

* Giving preference to a particular hand. The
  [choice](https://docs.python.org/3/library/random.html#random.choices)
  function in Python's random number library should help with this.

* Only playing two of the three possible hands.

#### Tournament

What we want to find out in this exercise is whether there is a
particular strategy that wins more often than others. To find out,
each strategy will compete against the other in two tournament styles:

* **Round-robin** Each player plays every other player in a best-of
  series. Once the tournament is finished, keep some number of
  top-performing players.
  
* **Knock-out** Each player plays their neighbor; the winner moves on
  (stays in the list). You should be able to use, as input, the list
  that was returned from the round-robin tournament.

These styles should be represented as functions that take a list of
strategies. Remember, functions are first-class, so you can make a
list as follows:

```python
def strategy_1():
    # ...

def strategy_2():
    # ...

# ...
def strategy_n():
    # ...

strategies = [
   strategy_1,
   strategy_2,
   # ...
   strategy_n
]
```

Note that during the tournament, ties do not count! In the event of a
tie, the game should be played again.


### <a name="hof"></a>2. Higher order functions
For-loops rely on the ability to continuously *bind* a value to a
*free* variable. Consider the statement

```python
for i in x:
    print(i)
```

where `x` is some sequence. `i` is initially free, but will be bound
to values in `x` as the loop progresses. In [some programming
languages](https://en.wikipedia.org/wiki/Functional_programming), once
a variable is bound, it can no longer be bound again. Such languages
thus do not have loops. To perform iteration, they instead must rely
on applying a function to pieces of a sequence.

Python has various methods that emulate this behavior; most notably
[map](https://docs.python.org/3/library/functions.html#map) and
[reduce](https://docs.python.org/3/library/functools.html#functools.reduce). Both
are functions that take two parameters: a function, and a
sequence. They subsequently apply the given function to the sequence:
`map` one element at a time; `reduce` two elements at a time (sort of:
it's actually the first two elements the first time, and the result of
the function over those two elements with individual remaining
elements subsequent times). The e-book "[Python
Tips](http://book.pythontips.com/en/latest/map_filter.html)" contains
good documentation of the basics of these methods.

After reading this documentation, challenge yourself to do some of the
previous exercises using `map` or `reduce`:

#### Integers

[Addition](#integers:addition) and
[multiplication](#integers:multiplication) can be accomplished using
`reduce`.

#### Strings

[Reverse](#strings:reverse) can be accomplished using
`reduce`. [Length](#strings:length), [single character
count](#strings:count), and [upper](#strings:upper) can be
accomplished using `map`. In the case of count, the Python built-in
function [sum](https://docs.python.org/3/library/functions.html#sum),
which adds a list of integers, may help. In the case of upper, you can
pass the result of `map` to the string method
[join](https://docs.python.org/3/library/stdtypes.html#str.join) to
produce the final string.

#### Lists

[Summation](#lists:summation), and
[randomization](#lists:randomization) can be accomplished using
`reduce` and `map`, respectively. In the documentation for `reduce`,
in fact, the example given is for summation:

```
>>> from functools import reduce
>>> help(reduce)
```


### <a name="generators"></a>3. Generators
Recall that in a typical function, once `return` is encountered that
function is done. Calling the function again will start the function
from the `def`-ining line.

*Generators* are functions whose return value doesn't necessarily kill
the function completely. Instead, control is returned to the caller
while a pointer is maintained within the function. When the function
is called again, it is run from this saved point. To differentiate
this "sort of" return from an actual return, the `yield` argument is
used:

```python
def f():
  return [1, 2, 3]

def g():
  for i in [1, 2, 3]:
     yield i
```

Note that in the first function a list is returned. In the second,
each value of the list is returned one-by-one. This makes it
particularly useful in a loop:

```python
  for i in g():
     print(i)
```

The advantage is that memory needs to be allocated for list members
rather than the entire list, which is the case when returning a single
value. This is particularly beneficial if there is a chance that
iterating through the entire sequence will not be necessary. Consider
a sequence with several million items, when, in most cases, only the
first few thousand are of interest.

One downside, however, is that you cannot determine the length of a
generator without running it to completion. Converting the generator
to a list is one short cut to doing so:

```
>>> len(list(g()))
3
```

As an aside, hopefully it is now clear why directly printing the
return value of range and dictionary keys do not actually return
items.

To practice, develop a function that, given a CSV file, *yield*s
dictionaries for each row.


### <a name="static"></a>4. Static variables
Recall that we said local variables are those local to a
function. Once a function is finished, those variables are gone. A
static variable, on the other hand, is a variable local to a function,
but whose value remains even after the function exits. They are well
defined concepts in other programming languages, but not (necessarily)
within Python.

However, because of the way Python "thinks of" functions, we can fake
it. Notably, Python supports function definitions *inside* of other
functions:
  
```python
def f():
   def g():
     return "World"
   return "Hello " + g()
```

The concept, more generally, is known as a
[closure](http://en.wikipedia.org/wiki/Closure_(computer_programming)). In
practice, it is more common that the outer function returns a
reference to the inner function:

```python
def f():
   def g():
     print("Hello World")
   return g
```

Now

```
>>> x = f()
>>> x()
Hello World
```

Update this example by making `f` and `g` accept arguments. Notice how
those arguments retain their values as `f` and `g` are called. Use
this knowledge to mimic static variables as defined above.

