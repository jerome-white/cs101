---
layout: post
title: "Lab 13: Recursion"
categories: lab
date: 0000-04-01
---

## Main Event


### <a name="intro"></a>1. Setup and instructions
This lab comes with more infrastructure than others. Please take a
moment to understand the framework.

#### Files

To begin, download the following files:

* [helpers.py]({{site.baseurl}}/assets/lab-13/helpers.py) Contains
  three methods that you will need to complete this lab:
  
  1. `head` returns the head of a list.
  
  2. `tail` returns the tail of a list.
  
  3. `month_days` returns a list corresponding to days in each month
      of the year: index zero corresponds to the number of days in
      January, index one to February, and so on.

  4. `elves` returns a list of words that are "elfish".

  The latter two methods are only useful if you decide to do the
  additional practice problems.

* [lab.py]({{site.baseurl}}/assets/lab-13/lab.py) This is where you
  will do your development. By default, the file contains function
  definitions that are correct, and return values that are
  incorrect. Your job is to replace the return values---and thus the
  function body's---with correct implementations.
  
* [test.py]({{site.baseurl}}/assets/lab-13/test.py) Contains methods
  that test your code. Do not edit this file. Instead, run this script
  once you feel you have completed a function in your lab file.

  When run, the script evaluates each uncommented function in lab.py
  *in the order that is specified in the lab*. Once one of the
  functions fails an evaluation, the program stops.

All files should be in the same directory.

#### Rules

Remember, **this is a lab on recursion**! You cannot access list
elements using subscript (bracket) notation, or using list
methods. List elements can only be accessed using the functions in
the helpers module:

```
>>> import helpers
>>> helpers.head([1, 2, 3])
1
>>> helpers.tail([1, 2, 3])
[2, 3]
```

Aside from these two functions, you can use native list concatenation
and list creation where appropriate. Further, your code should not
have any loops: no for-loops and no while-loops.

You may also be tempted to write "helper" methods that re-tool these
problems---all of these methods can be done without it. Challenge
yourself to think recursively!


### <a name="main"></a>2. Basics
1. Implement `rsum` such that, given a list of numbers, it returns the
   sum of that list. This is the exact problem we talked about in
   class; we're doing it again just to get warmed up.

2. The function `exponentiate` should return `base` to
   the power of `power`:
   
   ```
   >>> 2 ** 10 == exponentiate(2, 10)
   True
   ```

   You cannot use `**`! Hint: exponentiation can be written as a
   recurrence relation.

3. We typically use subscript notation to return an element of a
   list. The function `get_nth` should do this without it:
   
   ```
   >>> h = ['a', 'b', 'c']
   >>> h[2] == 
   'c'
   >>> get_nth(h, 2)
   'c'
   ```

4. Reverse a list (`reverse`) without using slicing or loops:

   ```
   >>> reverse([1, 2, 3])
   [3, 2, 1]
   ```

5. The function `is_older` takes two dates. It should return True if
   the first date (argument 1) comes before the second (argument 2);
   it should return False otherwise:

   ```
   >>> is_older([2015, 10, 27], [2015, 10, 28])
   True
   ```

   For this exercise (and subsequent additional practice exercises),
   we consider a "date" to a be a list of three integers. The first
   element is the year, the second element is the month, and the third
   element is the day.


## Additional Practice


### <a name="additional"></a>1. More basics
1. The function `number_before_reaching_sum` takes an integer,
   `total`, and a list of integers `numbers`. It should return an
   integer *n* such that the first *n* elements of the list sum to
   less-than `total`, but the first *n + 1* elements of the list sum
   to *total* or more:
  
   ```
   >>> number_before_reaching_sum(6, [0, 1, 2, 3, 4])
   3
   >>> number_before_reaching_sum(7, [0, 1, 2, 3, 4])
   4
   ```
   
   You can assume that the entire list sums to more than the specified
   value, and that the specified value is positive.
  
2. The function `what_month` takes a day of the year---an integer
   between 1 and 365---and returns the month, as an integer, that that
   day is in:
  
   ```
   >>> what_month(180)
   6
   ```

   The function `helpers.month_days` returns a list of integers
   corresponding to days in each month.


### <a name="elf"></a>2. Elfish words
Given two words, `elfish` should use recursion to decide whether all
of the letters in the second word, in any order, are contained in the
first. If so, it should return True; it should return False otherwise.

The method `helpers.elves` returns a list of words that all contain
the letter e, l, and f, in some order (the words are thus cononically
known as being "elfish"). Thus,

```python
for i in helpers.elves():
    if elfish(i, 'elf'):
       print(i)
```

would print every word in the list.


### <a name="coins"></a>3. Coin game
"Coin Game" consists of two players sitting in front of a mound of
coins. Each turn consists of a player taking one, two, or four coins
from the mound. The objective is to be the player that takes the last
coin.

1. Given the number of coins in the mound, `coin_game_strategies`
   should return the number of strategies there are for the potential
   winner to win *if each player is playing optimally*.

2. Given the number of coins, along with the two players---as two
   distinct string arguments, in playing order---`coin_game_winner`
   should return the player (as a string) who will ultimately win.

Assume that both players are very smart and will try their best to
work out a strategy to win the game. For example, assume Alice and Bob
are the players. if there are two coins and Alice is the first player
to pick, she will definitely pick two coins and win. If there are
three coins and Alice is still the first player to pick, regardless of
whether she pics one or two coins, Bob will get the last coin and win
the game.

