---
layout: post
title: "Lab 16: OOP continued"
categories: lab
date: 0000-04-22
---

## Main Event


### <a name="intro"></a>1. Introduction
"Particles" are ASCII characters that dance around your screen. In
this lab we will build such particles, along with the infrastructure
required to do so.


### <a name="particles"></a>2. Particle class
Here, we will simulate particles in space. In the global scope, we'll
need the following code:

```python
p = Particle(0, 0, 1, 1, 'o')
for i in range(100):
    board = make_board(10, 10)
    update_board(board, p)
    print_board(board)
    p.move()
```

This is how the infrastructure will be used. Notice that we'll need to
build a Particle class, whose constructor takes five arguments. The
class also contains a move method that takes no parameters. Finally,
there's the old board code. Notice now, however, that `make_board`
doesn't take a filler, and `update_board` only takes a board and a
Particle. Let's take a closer look at how this is done:

A particle is an object that has a position, a velocity, and an
identifier; all of which should be attributes of the class. The
position consists of an *x* and *y* coordinate---the first and second
argument of the Particle constructor above. The velocity can also be
represented as a pair: a velocity in the *x*-direction, and a velocity
in the *y*-direction. Representing both as integers is fine; they
should be the third and fourth parameters, respectively, of the
Particle constructor. A particle should also have an identifier: a
single character representation of itself; `'o'`, for example, as
denoted by the fifth parameter above.

A particle should be able to "move"; this is the purpose of the `move`
method. The method essentially increases the objects *x*-position by
the *x*-velocity, and its *y*-position by the *y*-velocity.


### <a name="board"></a>3. Board class
Now that the particle is in place, alter your board code to be
object-oriented instead of procedural. Thus, the code that previously
created a Particle and printed the board should be changed:

```python
p = Particle(0, 0, 1, 1, 'o')
for i in range(100):
    board = Board(10, 10)
    board.update(p)
    print(board)
    p.move()
```

For this to happen, you need to create a Board class:

1. Instead of being standalone functions---`make_board`,
   `update_board`, `print_board`---these should now be methods in a
   Board class.

2. Recall that the first argument to a method in Python is the
   variable `self`. Typically, when converting functions to methods
   you must insert this parameter into the existing list. In this
   case, however, one of the parameters lends itself naturally to
   being `self`...

3. Notice that `make_board` is essentially the constructor.

4. In order to use
   [print](https://docs.python.org/3/library/functions.html#print) on
   an object of type Board, Python needs to know how to cast a Board
   to string. It calls `__str__` to do so. Thus, your `print_board`
   should be called `__str__`.

   In Python, the semantics of `__str__` are that it does not actually
   print anything, but instead returns a value of type
   [string](https://docs.python.org/3/library/stdtypes.html#textseq)
   (which in turn can be printed by the caller). Thus, instead of
   making several calls to print, and thereby outputting various board
   elements to the screen, *it will create a string and return it*.


### <a name="pair"></a>4. Pair class
Notice that position and velocity are both pairs of numbers. To
*encapsulate* this abstraction, create a class Pair that contains two
integers and can be added (mathematically) to another Pair. From a
programming standpoint, we would like Particle creation to look like
this:

```python
position = Pair(0, 0) # initial spatial position
velocity = Pair(1, 1) # initial particle velocity
p = Particle(position, velocity, 'o')
```

Specifically, a pair is essentially a class that contains two
attributes of type integer. The ability to add one Pair to another
requires the implemention of the `__add__` method such that is sums
both attributes and returns a new Pair. A programmer would use your
class as follows:

```
>>> p1 = Point(0, 1)
>>> p2 = Point(1, 1)
>>> p3 = p1 + p2
>>> print(p3.x, p3.y)
1 2
```

Once implemented, alter your Particle code use this class.


### <a name="multiple"></a>5. Multiple particles
Instead of having a single particle, have multiple particles! Think
about the data types, and additional program structure, required to do
this:

* You will need to construct, and store, several particles.

* Each of these particles will need to be individually placed and
  moved.

* You can print the board after each, but doing so isn't optimal!


## Additional Practice


### <a name="animation"></a>1. Animated particles
Instead of printing the board sequentially, we'll now "update" the
screen such that only a single board appears to be printed. This
functionality works best when running your program from the command
line.

First, a few imports:

```python
import os
import time
```

Next, prior to printing your board, make the following calls:

```python
os.system('clear') # for Linux/Mac users
os.system('cls')   # for Windows users
print(board)       # the original statement
time.sleep(2 ** -2)
```

The first statement clears the screen. You only need one of the
`os.system` statements---choose the one appropriate for your
platform. The second pauses the program for a quarter of a second.

Next, run the program in terminal. For Mac users, find the location of
your Python file. If the location is /User/name/directory/file.py, for
example, then you can run the program as follows:

```bash
$> python3 "/User/name/directory/file.py"
```

Normally you don't need quotes, but if there are spaces anywhere in
the path---the stuff leading up to, and including, the file
name---then quotes are the easiest way to deal with it. If you're
having trouble, that's fine, just ask for assistance.


### <a name="trees"></a>2. Binary trees
Recall our discussion on trees: structures that stem "downward" from a
root node. Tree's can be general---each node having *n* number of
children---but for now we'll focus on binary trees: trees in which
each node has at most two children.

If you draw a tree, it's essentially a recursive data type: each node
has a value---the data that you want to store in the tree---and
attributes pointing toward its children. What makes a tree recursive
is that in order to point to the children, the variables have to be of
the same type as the class itself!

Implement such a class (call it Node):

* The constructor

  ```python
  def __init__(self, value)
  ```

  The class constructor should take a single parameter, `value`,
  representing the data of that child. It should also define two
  attributes, `left` and `right`, that *will eventually* be references
  to other Node's---at construction time you can give them default
  values that evaluate to false (`None` is generally best).

* Adding a value to the tree

  ```python
  def add(self, value)
  ```

  Given a single value, create a place for it in the
  tree. Specifically it should recursively walk the tree---going left
  or right depending on how the value compares to the current Node
  (`self`)---and adds itself as the appropriate (left or right) child
  of a `Node` that doesn't have one.

* Find a value within a tree

  ```python
  def find(self, value)
  ```

  Logically similar to `add`, but returns true if the value is found,
  and false otherwise.

There are numerous Python implementations of binary trees online. I
highly suggest you give this a try before resorting looking them up
(ask for help if you need!). The reason for this is because the
ability to implement a tree is a fundamental skill for a computer
scientist. In the near future, you will almost certainly have to
implement this next semester in data structures. In the longer term,
it's not uncommon for this to an expected ability during a technical
interview. Thinking through it now, when it doesn't really count, will
put you ahead of the game.

